---
title: Наследование 
sidebar: flexberry-designer_sidebar
keywords: Flexberry Desinger, Flexberry ORM, объекты данных
summary: Основные свойства наследования
toc: true
permalink: ru/fd_inheritance.html
lang: ru
---

Ассоциации наследования, подобные `Internal-InternalChild` называются `наследованием`, внутренний класс в такой ассоциации — `предок`, а внешний — `потомок`. 

![](/images/pages/products/flexberry-designer/about/uml-example1.jpg)

## Основные свойства наследования

* При наследовании атрибутный состав и состав связей всегда расширяется и не может сокращаться (при этом каждая унаследованная таблица [хранит `все` атрибуты `всех` предков](fo_storing-data-objects.html)).
* Наследнику доступны все атрибуты и ассоциации предка. Так, если взять за внутренний класс `InternalChild`, то его атрибуты будут `Attr1` и `Attr2`, мастера `Master1`, `Master2`, `Master3`, детейлы `Detail1, Detail2, Detail3, Detail4`.
* Предок обеспечивает полиморфный доступ ко всем своим наследникам, что означает, что экземпляру внутреннего класса и его наследникам (в данном случае — `Internal и InternalChild`) может быть установлен как экземпляр мастерового класса (в данном случае `Master2`), так и экземпляр любого наследника мастера (в данном случае `Master2Child`). Аналогична ситуация и с детейлами: экземпляр `Internal` одинаково, через `Detail2` оперирует с экземплярами `Detail2 и Detail2Child`, аналогично и для атрибутов и методов класса. На практике данное явление может вызвать [проблему, решаемую с помощью TypeUsage](fo_type-usage-problem.html), которое [особым образом отображается в структуру данных](fo_type-usage.html).
* Если у наследника есть атрибут, метод (с тем же составом параметров), ассоциация (с тем же именем роли), то это значит, что наследник `перегружает` данный элемент предка.
* Наследник от мастера может являться детейлом того же внутреннего класса (как в ситуации `Internal-Master1-Detail4`), это нормально.

{% include note.html content="Часто задаётся вопрос, почему таблицы [наследников](fd_inheritance.html) хранят все атрибуты всех предков, а не только свои. Ответ: тогда при чтении объекта-наследника необходимо собирать все атрибуты от таблиц предков по цепочке через `JOIN`, что очень медленно, особенно при чтении разнотипных объектов одним запросом. Следовательно, производительность приложения будет падать с ростом числа уровней наследования, что неприемлемо." %}
