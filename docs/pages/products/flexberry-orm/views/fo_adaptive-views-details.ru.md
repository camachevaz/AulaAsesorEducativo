---
title: Адаптивные представления для детейлов
sidebar: flexberry-orm_sidebar
keywords: Flexberry ORM, представления
summary: Предназначение и правила использования адаптивных детейлов
toc: true
permalink: ru/fo_adaptive-views-details.html
---

Например, имеется следующая ситуация:

![](/images/pages/products/flexberry-orm/views/adaptive-views-for-details.jpg)

Класс A имеет детейлы D, связанные агрегацией DA. Для A определено [представление](fd_view-definition.html), в которое связано представление детейла D.

Например, выполняется чтение объекта данных типа A по представлению `AView`.  Соответственно, поскольку объекты классов D1, D2 [унаследованы](fd_inheritance.html) от D, они также будут читаться по представлению `DView` (представления наследуются). Однако, что же делать, если они имеют более полный атрибутный состав, который _обязательно_ нуждается в прочитке?

Для того, чтобы разрешить данную проблему, существуют **адаптивные** представления. Если объявить представление `DView` адаптивным, а для детейлов D1 и D2 объявить представления с теми же именами (`DView`), но с собственным атрибутным составом, то [сервис данных](fo_data-service.html) будет прочитывать детейлы D1 и D2 в соответствии с ним.

Для того, чтобы указать, что представление адаптивно, необходимо при ассоциировании детейлового представления в атрибуте [AssociatedDetailViewAttribute](fd_view-definition.html) проинициализировать свойство `UseAdaptiveViewsLoading=true`.

Пример:

```csharp
[AssociatedDetailView("AView", "D", "DView", UseAdaptiveViewsLoading=true)]
```

{% include note.html content="Не следует злоупотреблять адаптивными представлениями, т.к. это негативно влияет на производительность. Во многих случаях лучше отдельно дочитывать детейловые объекты данных."%}

Реализация вычитки объектов-наследников по общему представлению предка описана в статье [Чтение принадлежащих различным классам объектов в одном представлении](fo_reading-several-types-objects.html).
