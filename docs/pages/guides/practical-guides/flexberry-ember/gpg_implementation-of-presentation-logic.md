---
title: Реализация презентационной логики
sidebar: guide-practical-guides_sidebar
keywords: guide, ember, ember-cli, validation, ember-cp-validations, observer
toc: true
permalink: ru/gpg_implementation-of-presentation-logic.html
lang: ru
---

Иногда возникают задачи, связанные с реализацией презентационной логики. В качестве примера рассмотрим реализацию логики формы Заказа при изменении статуса заказа на "Оплаченный":

1. сделать поле "Дата оплаты" обязательным при переводе Заказа в статус "Оплаченный" (до сохранения);
2. нужно исключить возможность изменять любые поля, кроме поля "Дата отгрузки" после перевода в статус "Оплаченный" - следовательно, их нужно заблокировать;
3. после списания товара нужно убрать валидацию с Содержимого заказа, т.к. необходимого объема товара на складах может уже не быть;
4. необходимо отписаться от обзервера на товар (Цена с налогом), чтобы цена товаров уже не менялась (цену товаров в конкретном заказе стоит фиксировать как минимум в момент подтверждения оплаты заказа, оптимально - когда выписывается накладная по заказу).

С учетом данных изменений, форма приобретет законченный в отношении события оплаты заказа вид.

## Условные валидаторы

Для того, чтобы валидатор на обязательность поля "Дата оплаты" срабатывал не всегда, мы должны отслеживать Статус заказа. Для таких ситуаций аддон **[ember-cp-validations](http://offirgolan.github.io/ember-cp-validations/docs/modules/Usage.html)** позволяет настраивать **условия работы валидатора**. Реализуем этот механизм **на примере** валидации поля **order.paymentDate**:

*`app → mixins → regenerated → models → i-i-s-shop-order.js`*

![Валидатор для поля paymentDate заказа](/images/pages/guides/flexberry-ember/8-implementation-of-presentation-logic/8-1.png)

Нам нужно **добавить** сюда один из **встроенных валидаторов** - валидатор на обязательность значения - **presence** (полный список доступных валидаторов аддона можно посмотреть тут - панель Classes):

{% highlight javascript%}
{% raw %}
paymentDate: {
  descriptionKey: 'models.i-i-s-shop-order.validations.paymentDate.__caption__',
  validators: [
    validator('ds-error'),
    validator('date'),
    validator('presence', true)
  ],
},
{% endraw %}
{% endhighlight %}

Если мы оставим его в таком виде, то валидация срабатывать будет всегда. Поэтому добавим условие валидации:

{% highlight javascript%}
{% raw %}
import OrderStatusEnum from '../enums/i-i-s-shop-order-status';
import { computed } from '@ember/object';
{% endraw %}
{% endhighlight %}

{% highlight javascript%}
{% raw %}
paymentDate: {
  descriptionKey: 'models.i-i-s-shop-order.validations.paymentDate.__caption__',
  validators: [
    validator('ds-error'),
    validator('date'),
    validator('presence', 
      presence: true,
      disabled: computed('model.status', function() {
        return this.get('model.status') !== OrderStatusEnum.Paid;
      })
    }),
  ],
},
{% endraw %}
{% endhighlight %}

{% include important.html content="Для валидаторов тоже применима работа с вычислимыми свойствами с использованием функции computed. Подробнее об общих настройках валидаторов можно почитать [здесь](https://rawgit.com/offirgolan/ember-cp-validations/c4123c983e54f24dd790ffa1bad66cfdf2f47ec6/docs/modules/Common%20Options.html)." %}

**Проверим**, как работает валидатор на примере **Заказа 1**:

![Условный валидатор не работает в форме редактирования заказ](/images/pages/guides/flexberry-ember/8-implementation-of-presentation-logic/8-4.png)

Если статус заказа перевести в "Оплаченный", то валидатор будет срабатывать:

![Условный валидатор работает в форме редактирования заказ](/images/pages/guides/flexberry-ember/8-implementation-of-presentation-logic/8-5.png)

Все работает корректно.

---

**_Самостоятельно_** настройте валидацию поля "Дата и время отгрузки" формы редактирования Накладной: поле обязательно для заполнения, если накладная имеет статус "Отгруженная"

---

## Блокировка полей формы

Наиболее простой и эффективный способ изменения внешнего вида форм - это настройка шаблона. Ранее мы уже меняли элементы шаблона, настраивая режим полей "только для чтения" в статичном (постоянном) режиме. Теперь для части полей нам необходимо настроить динамическую блокировку: поля должны блокироваться только в том случае, когда заказа имеет статус "Оплаченный" и не осталось никаких несохраненных изменений. **Блокировать** будем **всю форму целиком**, так как Оплаченный заказ нельзя отменить или вновь сделать новым.

**Добавим** в модель Заказа новое **вычислимое свойство isPaid**:

*`app → models → i-i-s-shop-order.js`*

{% highlight javascript%}
{% raw %}
import OrderStatusEnum from '../enums/i-i-s-shop-order-status';
import { computed } from '@ember/object';
{% endraw %}
{% endhighlight %}

{% highlight javascript%}
{% raw %}
let Model = DocumentModel.extend(OrderMixin, Validations, {
  isPaid: computed('status', function() {
    const status = this.get('status');
    const dirtyAttributes = this.get('hasDirtyAttributes');

    return status === OrderStatusEnum.Paid && !dirtyAttributes;
  })
});
{% endraw %}
{% endhighlight %}

{% include note.html content="Кроме проверки свойства status мы проверяем также наличие изменений во всех атрибутах модели с использованием флага hasDirtyAttributes. Это требуется для того, чтобы форма не блокировалась в момент, когда для заказа выбран статус &#34;Оплаченный&#34;, но сохранение еще не было выполнено.<br><br>
Настройку режима &#34;только для чтения&#34; применительно ко всей форме можно также осуществлять через свойство readonly в контроллере соответствующей формы (по умолчанию она имеет значение false, её можно видеть в шаблоне изначально). Однако, нам понадобится делать проверку на уровне модели, поэтому мы добавляем для этих целей отдельное свойство непосредственно в модели." %}

Далее нам нужно присвоить значение свойства модели **isPaid** свойству **readonly для всех полей формы** - по умолчанию оно имеет значение **false** (разрешено для редактирования). В качестве примера рассмотрим изменения для поля status:

*`app → templates → i-i-s-shop-order.hbs`*

**Проверим**, как работает блокировка полей на примере **Заказа 1**:

![Поля заказа не заблокированы](/images/pages/guides/flexberry-ember/8-implementation-of-presentation-logic/8-8.png)

Переведем в статус "Оплаченный" и сохраним:

![Поля заказа заблокированы](/images/pages/guides/flexberry-ember/8-implementation-of-presentation-logic/8-9.png)

Все работает корректно.

---

**_Самостоятельно_** настройте:
1. отключение валидации на форме Заказа с использованием нового свойства модели isPaid. При возникновении трудностей обратитесь к пункту "[Условные валидаторы](gpg_implementation-of-presentation-logic.html#условные-валидаторы)" и [документации по аддону](https://rawgit.com/offirgolan/ember-cp-validations/c4123c983e54f24dd790ffa1bad66cfdf2f47ec6/docs/modules/Usage.html);
2. скройте кнопки "Сохранить" и "Удалить" для формы редактирования заказа в состоянии "Оплачено".

---

## Условное поведение обзервера

До сих пор обзервер на обновление срабатывал каждый раз при загрузке формы, на которой он работает. В частности, если мы меняли цену товара и обновляли страницу заказа, то обзервер "подхватывал" новую цену и изменял все поля, связанные с ценой товара. **Проверим** данное поведение на примере **Заказа 2**:

<ol>
    <li>
        Изменим цену товара "Монитор Samsung C24F390FHI"
        <img src="/images/pages/guides/flexberry-ember/8-implementation-of-presentation-logic/8-10.png" alt="Изменение цены">
    </li>

    <li>
        Проверим состояние Заказа 2 (корректное поведение - форма заблокирована, цена с налогом у данного товара - 9900 руб.)
        <img src="/images/pages/guides/flexberry-ember/8-implementation-of-presentation-logic/8-11.png" alt="В заказе также изменилась цена">
    </li>
</ol>

Как мы видим, блокировка снята, а цена товара изменилась. В нашем случае такое поведение недопустимо, так как цена товара после оплаты на форме заказа меняться не может. Кроме того, снятие блокировки объясняется тем, что поле изменяется автоматически, а значит на заблокированной форме появляются несохраненные изменения, инициированные программно - а это одно из условий блокировки.

**Ограничим** срабатывание **обзервера** на пересчет **Цены с налогом** в детейле на форме редактирования Заказа:

*`app → models → i-i-s-shop-order-item.js`*

{% highlight javascript%}
{% raw %}
let Model = EmberFlexberryDataModel.extend(OfflineModelMixin, OrderItemMixin, Validations, {
  taxes: 10,

  // Цена с налогом
  _priceWTaxesChanged: on('init', observer('product', function() {
    if (!this.get('order.isPaid')) {
      once(this, '_priceWTaxesCompute');
    }
  })),

  ...

}
{% endraw %}
{% endhighlight %}

Так как все остальные обзерверы на форме связаны со значением поля "Цена с налогом", то, остановив срабатывание этого обзервера, мы "отключим" и все остальные. 

{% include note.html content="Свойство isPaid модели order высчитывается раньше инициализации модели order-item. Это связано с тем, что вторая модель инициируется в рамках первой, и потому обзервер всегда будет срабатывать корректно." %}

**Проверим** внесенные изменения на примере **Заказа 2**:

![Поля заказа заблокированы](/images/pages/guides/flexberry-ember/8-implementation-of-presentation-logic/8-13.png)

Все работает корректно.

---

**_Самостоятельно_** настройте блокировку формы заказа для статуса "Отмененный".

*<u>Подсказка</u>*: можно расширить функционал существующей блокировки для статуса "Оплаченный" (isPaid) до общего врианта isBlocked.

---

## Итог

В процессе внесенных в данной главе изменений мы настроили поведение формы редактирования Заказа в соответствиями с требуемой логикой. В результате форма "Заказ" приобрела вид, с которым комфортно было бы работать потенциальному пользователю.

 **[Итоговое приложение](https://github.com/Flexberry/flexberry-developers-school/tree/master/%D0%9F%D1%80%D0%B8%D0%BC%D0%B5%D1%80%D1%8B/%D0%9C%D0%BE%D0%B4%D1%83%D0%BB%D1%8C%208/%D0%9F%D1%80%D0%B0%D0%BA%D1%82%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5%20%D1%80%D1%83%D0%BA%D0%BE%D0%B2%D0%BE%D0%B4%D1%81%D1%82%D0%B2%D0%B0/%D0%9F%D1%80%D0%B0%D0%BA%D1%82%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%BE%D0%B5%20%D1%80%D1%83%D0%BA%D0%BE%D0%B2%D0%BE%D0%B4%D1%81%D1%82%D0%B2%D0%BE%20%D0%BF%D0%BE%20%D1%81%D0%BE%D0%B7%D0%B4%D0%B0%D0%BD%D0%B8%D1%8E%20%D0%B2%D0%B5%D0%B1-%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D0%B9%20%D0%BD%D0%B0%20Flexberry%20Ember)** размещено в репозитории: стадии до и после работы, скрипт на создание структуры базы данных, приложение со всеми доработками (кроме самостоятельных заданий).

## Самостоятельная работа

Вы можете выполнить следующие доработки в приложении самостоятельно для более полной реализации функционала приложения:
1. запретить создание Накладной пользователем (убрать кнопку "Добавить" в списковой форме Накладные);

## Перейти

* [Практическое руководство  «Делай как я»](gpg_landing-page.html) <i class="fa fa-arrow-up" aria-hidden="true"></i>

* [Реализация серверной логики](gpg_server-logic-implementation.html) <i class="fa fa-arrow-left" aria-hidden="true"></i>
